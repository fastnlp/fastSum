.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::DOM::Node 3pm"
.TH XML::DOM::Node 3pm "2015-08-17" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::DOM::Node \- Super class of all nodes in XML::DOM
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::DOM::Node is the super class of all nodes in an \s-1XML::DOM\s0 document.
This means that all nodes that subclass XML::DOM::Node also inherit all
the methods that XML::DOM::Node implements.
.SS "\s-1GLOBAL VARIABLES\s0"
.IX Subsection "GLOBAL VARIABLES"
.ie n .IP "@NodeNames" 4
.el .IP "\f(CW@NodeNames\fR" 4
.IX Item "@NodeNames"
The variable \f(CW@XML::DOM::Node::NodeNames\fR maps the node type constants to strings.
It is used by XML::DOM::Node::getNodeTypeName.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "getNodeType" 4
.IX Item "getNodeType"
Return an integer indicating the node type. See \s-1XML::DOM\s0 constants.
.IP "getNodeName" 4
.IX Item "getNodeName"
Return a property or a hardcoded string, depending on the node type.
Here are the corresponding functions or values:
.Sp
.Vb 10
\& Attr                   getName
\& AttDef                 getName
\& AttlistDecl            getName
\& CDATASection           "#cdata\-section"
\& Comment                "#comment"
\& Document               "#document"
\& DocumentType           getNodeName
\& DocumentFragment       "#document\-fragment"
\& Element                getTagName
\& ElementDecl            getName
\& EntityReference        getEntityName
\& Entity                 getNotationName
\& Notation               getName
\& ProcessingInstruction  getTarget
\& Text                   "#text"
\& XMLDecl                "#xml\-declaration"
.Ve
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: AttDef, AttlistDecl, ElementDecl and XMLDecl were added for
completeness.
.IP "getNodeValue and setNodeValue (value)" 4
.IX Item "getNodeValue and setNodeValue (value)"
Returns a string or undef, depending on the node type. This method is provided 
for completeness. In other languages it saves the programmer an upcast.
The value is either available thru some other method defined in the subclass, or
else undef is returned. Here are the corresponding methods: 
Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, 
ProcessingInstruction::getData.
.IP "getParentNode and setParentNode (parentNode)" 4
.IX Item "getParentNode and setParentNode (parentNode)"
The parent of this node. All nodes, except Document,
DocumentFragment, and Attr may have a parent. However, if a
node has just been created and not yet added to the tree, or
if it has been removed from the tree, this is undef.
.IP "getChildNodes" 4
.IX Item "getChildNodes"
A NodeList that contains all children of this node. If there
are no children, this is a NodeList containing no nodes. The
content of the returned NodeList is \*(L"live\*(R" in the sense that,
for instance, changes to the children of the node object that
it was created from are immediately reflected in the nodes
returned by the NodeList accessors; it is not a static
snapshot of the content of the node. This is true for every
NodeList, including the ones returned by the
getElementsByTagName method.
.Sp
\&\s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for
getElementsByTagName. See \s-1CAVEATS\s0.
.Sp
When this method is called in a list context, it returns a regular perl list
containing the child nodes. Note that this list is not \*(L"live\*(R". E.g.
.Sp
.Vb 3
\& @list = $node\->getChildNodes;        # returns a perl list
\& $nodelist = $node\->getChildNodes;    # returns a NodeList (object reference)
\& for my $kid ($node\->getChildNodes)   # iterate over the children of $node
.Ve
.IP "getFirstChild" 4
.IX Item "getFirstChild"
The first child of this node. If there is no such node, this returns undef.
.IP "getLastChild" 4
.IX Item "getLastChild"
The last child of this node. If there is no such node, this returns undef.
.IP "getPreviousSibling" 4
.IX Item "getPreviousSibling"
The node immediately preceding this node. If there is no such 
node, this returns undef.
.IP "getNextSibling" 4
.IX Item "getNextSibling"
The node immediately following this node. If there is no such node, this returns 
undef.
.IP "getAttributes" 4
.IX Item "getAttributes"
A NamedNodeMap containing the attributes (Attr nodes) of this node 
(if it is an Element) or undef otherwise.
Note that adding/removing attributes from the returned object, also adds/removes
attributes from the Element node that the NamedNodeMap came from.
.IP "getOwnerDocument" 4
.IX Item "getOwnerDocument"
The Document object associated with this node. This is also
the Document object used to create new nodes. When this node
is a Document this is undef.
.IP "insertBefore (newChild, refChild)" 4
.IX Item "insertBefore (newChild, refChild)"
Inserts the node newChild before the existing child node
refChild. If refChild is undef, insert newChild at the end of
the list of children.
.Sp
If newChild is a DocumentFragment object, all of its children
are inserted, in the same order, before refChild. If the
newChild is already in the tree, it is first removed.
.Sp
Return Value: The node being inserted.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to insert is one of this node's ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newChild was created from a different document than the one that 
created this node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if this node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if refChild is not a child of this node.
.RE
.RS 4
.RE
.IP "replaceChild (newChild, oldChild)" 4
.IX Item "replaceChild (newChild, oldChild)"
Replaces the child node oldChild with newChild in the list of
children, and returns the oldChild node. If the newChild is
already in the tree, it is first removed.
.Sp
Return Value: The node replaced.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if this node is of a type that does not allow children of the type of
the newChild node, or it the node to put in is one of this node's ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newChild was created from a different document than the one that 
created this node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if this node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if oldChild is not a child of this node.
.RE
.RS 4
.RE
.IP "removeChild (oldChild)" 4
.IX Item "removeChild (oldChild)"
Removes the child node indicated by oldChild from the list of
children, and returns it.
.Sp
Return Value: The node removed.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if this node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if oldChild is not a child of this node.
.RE
.RS 4
.RE
.IP "appendChild (newChild)" 4
.IX Item "appendChild (newChild)"
Adds the node newChild to the end of the list of children of
this node. If the newChild is already in the tree, it is
first removed. If it is a DocumentFragment object, the entire contents of 
the document fragment are moved into the child list of this node
.Sp
Return Value: The node added.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to append is one of this node's ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newChild was created from a different document than the one that 
created this node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if this node is readonly.
.RE
.RS 4
.RE
.IP "hasChildNodes" 4
.IX Item "hasChildNodes"
This is a convenience method to allow easy determination of
whether a node has any children.
.Sp
Return Value: 1 if the node has any children, 0 otherwise.
.IP "cloneNode (deep)" 4
.IX Item "cloneNode (deep)"
Returns a duplicate of this node, i.e., serves as a generic
copy constructor for nodes. The duplicate node has no parent
(parentNode returns undef.).
.Sp
Cloning an Element copies all attributes and their values,
including those generated by the \s-1XML\s0 processor to represent
defaulted attributes, but this method does not copy any text
it contains unless it is a deep clone, since the text is
contained in a child Text node. Cloning any other type of
node simply returns a copy of this node.
.Sp
Parameters: 
 \fIdeep\fR   If true, recursively clone the subtree under the specified node.
If false, clone only the node itself (and its attributes, if it is an Element).
.Sp
Return Value: The duplicate node.
.IP "normalize" 4
.IX Item "normalize"
Puts all Text nodes in the full depth of the sub-tree
underneath this Element into a \*(L"normal\*(R" form where only
markup (e.g., tags, comments, processing instructions, \s-1CDATA\s0
sections, and entity references) separates Text nodes, i.e.,
there are no adjacent Text nodes. This can be used to ensure
that the \s-1DOM\s0 view of a document is the same as if it were
saved and re-loaded, and is useful when operations (such as
XPointer lookups) that depend on a particular document tree
structure are to be used.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: In the \s-1DOM\s0 Spec this method is defined in the Element and 
Document class interfaces only, but it doesn't hurt to have it here...
.IP "getElementsByTagName (name [, recurse])" 4
.IX Item "getElementsByTagName (name [, recurse])"
Returns a NodeList of all descendant elements with a given
tag name, in the order in which they would be encountered in
a preorder traversal of the Element tree.
.Sp
Parameters:
 \fIname\fR  The name of the tag to match on. The special value \*(L"*\*(R" matches all tags.
 \fIrecurse\fR  Whether it should return only direct child nodes (0) or any descendant that matches the tag name (1). This argument is optional and defaults to 1. It is not part of the \s-1DOM\s0 spec.
.Sp
Return Value: A list of matching Element nodes.
.Sp
\&\s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for
getElementsByTagName. See \s-1CAVEATS\s0.
.Sp
When this method is called in a list context, it returns a regular perl list
containing the result nodes. E.g.
.Sp
.Vb 3
\& @list = $node\->getElementsByTagName("tag");       # returns a perl list
\& $nodelist = $node\->getElementsByTagName("tag");   # returns a NodeList (object ref.)
\& for my $elem ($node\->getElementsByTagName("tag")) # iterate over the result nodes
.Ve
.SS "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.IP "getNodeTypeName" 4
.IX Item "getNodeTypeName"
Return the string describing the node type. 
E.g. returns \*(L"\s-1ELEMENT_NODE\*(R"\s0 if getNodeType returns \s-1ELEMENT_NODE.\s0
It uses \f(CW@XML::DOM::Node::NodeNames\fR.
.IP "toString" 4
.IX Item "toString"
Returns the entire subtree as a string.
.IP "printToFile (filename)" 4
.IX Item "printToFile (filename)"
Prints the entire subtree to the file with the specified filename.
.Sp
Croaks: if the file could not be opened for writing.
.IP "printToFileHandle (handle)" 4
.IX Item "printToFileHandle (handle)"
Prints the entire subtree to the file handle.
E.g. to print to \s-1STDOUT:\s0
.Sp
.Vb 1
\& $node\->printToFileHandle (\e*STDOUT);
.Ve
.IP "print (obj)" 4
.IX Item "print (obj)"
Prints the entire subtree using the object's print method. E.g to print to a
FileHandle object:
.Sp
.Vb 2
\& $f = new FileHandle ("file.out", "w");
\& $node\->print ($f);
.Ve
.IP "getChildIndex (child)" 4
.IX Item "getChildIndex (child)"
Returns the index of the child node in the list returned by getChildNodes.
.Sp
Return Value: the index or \-1 if the node is not found.
.IP "getChildAtIndex (index)" 4
.IX Item "getChildAtIndex (index)"
Returns the child node at the specified index or undef.
.IP "addText (text)" 4
.IX Item "addText (text)"
Appends the specified string to the last child if it is a Text node, or else 
appends a new Text node (with the specified text.)
.Sp
Return Value: the last child if it was a Text node or else the new Text node.
.IP "dispose" 4
.IX Item "dispose"
Removes all circular references in this node and its descendants so the 
objects can be claimed for garbage collection. The objects should not be used
afterwards.
.IP "setOwnerDocument (doc)" 4
.IX Item "setOwnerDocument (doc)"
Sets the ownerDocument property of this node and all its children (and 
attributes etc.) to the specified document.
This allows the user to cut and paste document subtrees between different
XML::DOM::Documents. The node should be removed from the original document
first, before calling setOwnerDocument.
.Sp
This method does nothing when called on a Document node.
.IP "isAncestor (parent)" 4
.IX Item "isAncestor (parent)"
Returns 1 if parent is an ancestor of this node or if it is this node itself.
.IP "expandEntityRefs (str)" 4
.IX Item "expandEntityRefs (str)"
Expands all the entity references in the string and returns the result.
The entity references can be character references (e.g. \*(L"&#123;\*(R" or \*(L"&#x1fc2\*(R"),
default entity references (\*(L"&quot;\*(R", \*(L"&gt;\*(R", \*(L"&lt;\*(R", \*(L"&apos;\*(R" and \*(L"&amp;\*(R") or
entity references defined in Entity objects as part of the DocumentType of
the owning Document. Character references are expanded into \s-1UTF\-8.\s0
Parameter entity references (e.g. \f(CW%ent\fR;) are not expanded.
.ie n .IP "to_sax ( %HANDLERS )" 4
.el .IP "to_sax ( \f(CW%HANDLERS\fR )" 4
.IX Item "to_sax ( %HANDLERS )"
E.g.
.Sp
.Vb 2
\& $node\->to_sax (DocumentHandler => $my_handler, 
\&                Handler => $handler2 );
.Ve
.Sp
\&\f(CW%HANDLERS\fR may contain the following handlers:
.RS 4
.IP "\(bu" 4
DocumentHandler
.IP "\(bu" 4
DTDHandler
.IP "\(bu" 4
EntityResolver
.IP "\(bu" 4
Handler
.Sp
Default handler when one of the above is not specified
.RE
.RS 4
.Sp
Each XML::DOM::Node generates the appropriate \s-1SAX\s0 callbacks (for the
appropriate \s-1SAX\s0 handler.) Different \s-1SAX\s0 handlers can be plugged in to
accomplish different things, e.g. XML::Checker would check the node 
(currently only Document and Element nodes are supported), XML::Handler::BuildDOM
would create a new \s-1DOM\s0 subtree (thereby, in essence, copying the Node)
and in the near future, XML::Writer could print the node.
All Perl \s-1SAX\s0 related work is still in flux, so this interface may change a 
little.
.Sp
See PerlSAX for the description of the \s-1SAX\s0 interface.
.RE
.IP "check ( [$checker] )" 4
.IX Item "check ( [$checker] )"
See descriptions for \fIcheck()\fR in XML::DOM::Document and XML::DOM::Element.
.ie n .IP "xql ( @XQL_OPTIONS )" 4
.el .IP "xql ( \f(CW@XQL_OPTIONS\fR )" 4
.IX Item "xql ( @XQL_OPTIONS )"
To use the xql method, you must first \fIuse\fR \s-1XML::XQL\s0 and \s-1XML::XQL::DOM\s0.
This method is basically a shortcut for:
.Sp
.Vb 2
\& $query = new XML::XQL::Query ( @XQL_OPTIONS );
\& return $query\->solve ($node);
.Ve
.Sp
If the first parameter in \f(CW@XQL_OPTIONS\fR is the \s-1XQL\s0 expression, you can leave off
the 'Expr' keyword, so:
.Sp
.Vb 1
\& $node\->xql ("doc//elem1[@attr]", @other_options);
.Ve
.Sp
is identical to:
.Sp
.Vb 1
\& $node\->xql (Expr => "doc//elem1[@attr]", @other_options);
.Ve
.Sp
See XML::XQL::Query for other available \s-1XQL_OPTIONS.\s0
See \s-1XML::XQL\s0 and XML::XQL::Tutorial for more info.
.IP "isHidden ()" 4
.IX Item "isHidden ()"
Whether the node is hidden.
See Hidden Nodes for details.
